# {{ config.name }} - Cloud Build Configuration
# Generated by: bedsheet deploy --target gcp
#
# This builds and deploys your agent to Cloud Run using Artifact Registry.

substitutions:
  _REGION: {{ gcp.region or 'europe-west1' }}
  # GCP resource names can't have underscores, use hyphens
  _SERVICE: {{ project_name | replace('_', '-') }}
  _REPO: {{ project_name | replace('_', '-') }}-repo
  # Override with commit SHA for CI/CD triggers: --substitutions=_TAG=$SHORT_SHA
  _TAG: latest

steps:
  # Step 1: Enable required APIs (Cloud Build service account has permissions)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'enable-apis'
    entrypoint: bash
    args:
      - '-c'
      - |
        echo "Enabling required GCP APIs..."
        gcloud services enable \
          cloudresourcemanager.googleapis.com \
          run.googleapis.com \
          artifactregistry.googleapis.com \
          aiplatform.googleapis.com \
          cloudbuild.googleapis.com \
          logging.googleapis.com \
          monitoring.googleapis.com \
          iam.googleapis.com \
          iamcredentials.googleapis.com \
          --quiet
        echo "APIs enabled."

  # Step 2: Create GCS bucket for Terraform state (if it doesn't exist)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'create-state-bucket'
    entrypoint: bash
    args:
      - '-c'
      - |
        BUCKET="{{ config.name }}-tfstate-$PROJECT_ID"
        echo "Ensuring Terraform state bucket exists: gs://$$BUCKET"
        gcloud storage buckets describe gs://$$BUCKET 2>/dev/null || \
        gcloud storage buckets create gs://$$BUCKET \
          --location=${_REGION} \
          --uniform-bucket-level-access \
          --public-access-prevention
        echo "State bucket ready."

  # Step 3: Run Terraform to create infrastructure
  - name: 'hashicorp/terraform:1.9'
    id: 'terraform-init'
    dir: 'terraform'
    entrypoint: sh
    env:
      - 'TF_INPUT=0'
    args:
      - '-c'
      - |
        echo "Initializing Terraform..."
        # Remove any local state that might conflict
        rm -rf .terraform .terraform.lock.hcl terraform.tfstate* 2>/dev/null || true
        terraform init -backend-config="bucket={{ config.name }}-tfstate-$PROJECT_ID"

  - name: 'hashicorp/terraform:1.9'
    id: 'terraform-apply'
    dir: 'terraform'
    entrypoint: sh
    args:
      - '-c'
      - |
        echo "Applying Terraform..."
        cat > terraform.tfvars <<EOF
        project_id = "$PROJECT_ID"
        region     = "${_REGION}"
        EOF
        terraform apply -auto-approve -input=false

  # Step 4: Grant IAM roles to service account
  # Using gcloud instead of Terraform for better CI/CD reliability
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'grant-iam-roles'
    entrypoint: bash
    args:
      - '-c'
      - |
        SA_EMAIL="${_SERVICE}-sa@$PROJECT_ID.iam.gserviceaccount.com"
        echo "Granting IAM roles to $$SA_EMAIL..."

        # Vertex AI User - Access to Gemini models
        gcloud projects add-iam-policy-binding $PROJECT_ID \
          --member="serviceAccount:$$SA_EMAIL" \
          --role="roles/aiplatform.user" \
          --quiet

        # Cloud Logging Writer
        gcloud projects add-iam-policy-binding $PROJECT_ID \
          --member="serviceAccount:$$SA_EMAIL" \
          --role="roles/logging.logWriter" \
          --quiet

        # Cloud Monitoring Metric Writer
        gcloud projects add-iam-policy-binding $PROJECT_ID \
          --member="serviceAccount:$$SA_EMAIL" \
          --role="roles/monitoring.metricWriter" \
          --quiet

        # Cloud Trace Agent
        gcloud projects add-iam-policy-binding $PROJECT_ID \
          --member="serviceAccount:$$SA_EMAIL" \
          --role="roles/cloudtrace.agent" \
          --quiet

        echo "IAM roles granted."

  # Step 5: Build container image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'build'
    args:
      - 'build'
      - '-t'
      - '${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_SERVICE}:${_TAG}'
      - '.'

  # Push to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - '${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_SERVICE}:${_TAG}'

  # Deploy to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - '${_SERVICE}'
      - '--image'
      - '${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_SERVICE}:${_TAG}'
      - '--region'
      - '${_REGION}'
      - '--platform'
      - 'managed'
      - '--allow-unauthenticated'
      - '--service-account'
      - '${_SERVICE}-sa@$PROJECT_ID.iam.gserviceaccount.com'
      - '--set-env-vars'
      - 'GOOGLE_CLOUD_PROJECT=$PROJECT_ID,GOOGLE_CLOUD_LOCATION=global,GOOGLE_GENAI_USE_VERTEXAI=true'
      {% if gcp.cloud_run_memory %}
      - '--memory'
      - '{{ gcp.cloud_run_memory }}'
      {% endif %}

  # Print the service URL
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: bash
    args:
      - '-c'
      - |
        echo ""
        echo "============================================"
        echo "ğŸ‰ Deployment complete!"
        echo "============================================"
        SERVICE_URL=$$(gcloud run services describe ${_SERVICE} --region ${_REGION} --format 'value(status.url)')
        echo ""
        echo "Your agent is live at:"
        echo "  $$SERVICE_URL"
        echo ""
        echo "Test it (ADK uses /run endpoint):"
        echo "  curl -X POST $$SERVICE_URL/run -H 'Content-Type: application/json' -d '{\"app_name\": \"agent\", \"user_id\": \"test\", \"session_id\": \"s1\", \"new_message\": {\"role\": \"user\", \"parts\": [{\"text\": \"Hello!\"}]}}'"
        echo ""

images:
  - '${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_SERVICE}:${_TAG}'

options:
  logging: CLOUD_LOGGING_ONLY

timeout: '1200s'
