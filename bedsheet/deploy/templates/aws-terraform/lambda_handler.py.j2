"""
{{ config.name }} - Bedrock Agent Action Handler
Generated by: bedsheet deploy --target aws

Simple handler using only standard library (no external dependencies).
"""
import logging
import json
{% if agent.tools | selectattr('name', 'equalto', 'delegate') | list %}
import boto3
import os
{% endif %}

logger = logging.getLogger()
logger.setLevel(logging.INFO)
{% if agent.tools | selectattr('name', 'equalto', 'delegate') | list %}

# Bedrock Runtime client for delegate action
bedrock_runtime = boto3.client('bedrock-agent-runtime', region_name=os.environ.get('AWS_REGION'))
{% endif %}


{% for tool in agent.tools %}
{% if tool.name == 'delegate' %}
def delegate(agent_name: str, task: str) -> str:
    """{{ tool.description }}"""
    logger.info(f"Delegating to {agent_name}: {task}")

    # Map collaborator names to their agent/alias ARNs (from environment variables)
    collaborators = {}
    {% for collaborator in agent.collaborators %}
    collaborators["{{ collaborator.name }}"] = {
        "agent_id": os.environ.get("COLLABORATOR_{{ collaborator.name | upper }}_AGENT_ID"),
        "alias_id": os.environ.get("COLLABORATOR_{{ collaborator.name | upper }}_ALIAS_ID"),
    }
    {% endfor %}

    if agent_name not in collaborators:
        return f"Unknown collaborator: {agent_name}. Available: {list(collaborators.keys())}"

    collab = collaborators[agent_name]

    try:
        # Invoke collaborator agent via Bedrock
        response = bedrock_runtime.invoke_agent(
            agentId=collab["agent_id"],
            agentAliasId=collab["alias_id"],
            sessionId=f"delegate-{agent_name}",
            inputText=task
        )

        # Collect response from event stream
        result = ""
        for event in response['completion']:
            if 'chunk' in event:
                chunk = event['chunk']
                if 'bytes' in chunk:
                    result += chunk['bytes'].decode('utf-8')

        return result

    except Exception as e:
        logger.exception(f"Failed to delegate to {agent_name}")
        return f"Error delegating to {agent_name}: {str(e)}"


{% else %}
def {{ tool.name }}({% for param in tool.parameters %}{{ param.name }}: {{ param.type_hint or 'str' }}{% if param.default is not none %} = {{ param.default | tojson }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}) -> str:
    """{{ tool.description }}"""
    # TODO: Implement tool logic
    # Original Bedsheet action: {{ tool.name }}
    logger.info(f"Executing {{ tool.name }}")
    raise NotImplementedError("Implement {{ tool.name }} tool logic")


{% endif %}
{% endfor %}

# Action mapping
ACTIONS = {
    {% for tool in agent.tools %}
    "{{ tool.name }}": {{ tool.name }},
    {% endfor %}
}


def lambda_handler(event: dict, context) -> dict:
    """Handle Bedrock Agent action group invocations.

    Event structure:
    {
        "actionGroup": "action_group_name",
        "apiPath": "/action_name",
        "httpMethod": "POST",
        "parameters": [...],
        "requestBody": {...}
    }
    """
    logger.info(f"Received event: {json.dumps(event)}")

    # Extract action name from API path
    api_path = event.get("apiPath", "")
    action_name = api_path.strip("/")

    if action_name not in ACTIONS:
        return {
            "messageVersion": "1.0",
            "response": {
                "actionGroup": event.get("actionGroup"),
                "apiPath": api_path,
                "httpMethod": event.get("httpMethod"),
                "httpStatusCode": 404,
                "responseBody": {
                    "application/json": {
                        "body": f"Action not found: {action_name}"
                    }
                }
            }
        }

    # Extract parameters
    params = {}
    for param in event.get("parameters", []):
        params[param["name"]] = param["value"]

    # Execute action
    try:
        action_fn = ACTIONS[action_name]
        result = action_fn(**params)

        return {
            "messageVersion": "1.0",
            "response": {
                "actionGroup": event.get("actionGroup"),
                "apiPath": api_path,
                "httpMethod": event.get("httpMethod"),
                "httpStatusCode": 200,
                "responseBody": {
                    "application/json": {
                        "body": result
                    }
                }
            }
        }
    except Exception as e:
        logger.exception("Action failed")
        return {
            "messageVersion": "1.0",
            "response": {
                "actionGroup": event.get("actionGroup"),
                "apiPath": api_path,
                "httpMethod": event.get("httpMethod"),
                "httpStatusCode": 500,
                "responseBody": {
                    "application/json": {
                        "body": f"Error: {str(e)}"
                    }
                }
            }
        }
