"""AgentCore Runtime Server for {{ config.name }}.

Generated by Bedsheet v0.4.7

This server implements the AgentCore HTTP Protocol Contract:
- POST /invocations - Agent interaction (JSON or SSE response)
- GET /ping - Health check

Reference: https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-http-protocol-contract.html
"""
import json
import logging
import time
import uuid
from typing import AsyncGenerator

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse, StreamingResponse
from pydantic import BaseModel

from bedsheet.events import (
    CompletionEvent,
    ToolCallEvent,
    ToolResultEvent,
    ThinkingEvent,
    ErrorEvent,
    DelegationEvent,
    CollaboratorStartEvent,
    CollaboratorCompleteEvent,
)

# Import the agent
# TODO: Update this import path to match your agent module
from agents.{{ config.agents[0].module.split('.')[-1] }} import {{ config.agents[0].class_name.lower() }} as agent

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# FastAPI app
app = FastAPI(
    title="{{ config.name }} AgentCore Runtime",
    description="Bedsheet agent deployed to Amazon Bedrock AgentCore",
    version="0.4.7",
)


class InvocationRequest(BaseModel):
    """Request body for /invocations endpoint."""
    prompt: str
    session_id: str | None = None
    stream: bool = True


class HealthResponse(BaseModel):
    """Response body for /ping endpoint."""
    status: str
    time_of_last_update: int


@app.get("/ping", response_model=HealthResponse)
async def ping() -> HealthResponse:
    """Health check endpoint required by AgentCore.

    Returns:
        HealthResponse with status "Healthy" or "HealthyBusy"
    """
    return HealthResponse(
        status="Healthy",
        time_of_last_update=int(time.time())
    )


@app.post("/invocations")
async def invocations(request: Request):
    """Main invocation endpoint for AgentCore.

    Supports both JSON and SSE (Server-Sent Events) responses.
    Use stream=true for real-time event streaming.
    """
    try:
        body = await request.json()
    except Exception as e:
        logger.error(f"Failed to parse request body: {e}")
        return JSONResponse(
            status_code=400,
            content={"error": "Invalid JSON in request body"}
        )

    # Parse request
    prompt = body.get("prompt", "")
    session_id = body.get("session_id", str(uuid.uuid4()))
    stream = body.get("stream", True)

    if not prompt:
        return JSONResponse(
            status_code=400,
            content={"error": "Missing 'prompt' in request body"}
        )

    logger.info(f"Invocation: session={session_id}, stream={stream}, prompt={prompt[:100]}...")

    if stream:
        # SSE streaming response
        return StreamingResponse(
            event_generator(session_id, prompt),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "X-Accel-Buffering": "no",
            },
        )
    else:
        # Non-streaming JSON response
        response_text = ""
        try:
            async for event in agent.invoke(session_id, prompt):
                if isinstance(event, CompletionEvent):
                    response_text = event.response
        except Exception as e:
            logger.error(f"Agent invocation failed: {e}")
            return JSONResponse(
                status_code=500,
                content={"error": str(e), "session_id": session_id}
            )

        return JSONResponse(
            content={
                "response": response_text,
                "session_id": session_id,
                "status": "success"
            }
        )


async def event_generator(session_id: str, prompt: str) -> AsyncGenerator[str, None]:
    """Generate SSE events from agent invocation.

    Event format follows SSE specification:
    data: {"type": "event_type", ...}\n\n
    """
    # Send session start event
    yield f"data: {json.dumps({'type': 'session', 'session_id': session_id})}\n\n"

    try:
        async for event in agent.invoke(session_id, prompt):
            event_data = _serialize_event(event)
            if event_data:
                yield f"data: {json.dumps(event_data)}\n\n"
    except Exception as e:
        logger.error(f"Agent invocation error: {e}")
        yield f"data: {json.dumps({'type': 'error', 'error': str(e)})}\n\n"

    # Send completion marker
    yield f"data: {json.dumps({'type': 'done'})}\n\n"


def _serialize_event(event) -> dict | None:
    """Serialize a Bedsheet event to JSON-compatible dict."""
    if isinstance(event, ThinkingEvent):
        return {
            "type": "thinking",
            "content": event.content,
        }
    elif isinstance(event, ToolCallEvent):
        return {
            "type": "tool_call",
            "tool_name": event.tool_name,
            "tool_input": event.tool_input,
        }
    elif isinstance(event, ToolResultEvent):
        return {
            "type": "tool_result",
            "tool_name": event.tool_name,
            "result": str(event.result)[:1000],  # Truncate large results
        }
    elif isinstance(event, DelegationEvent):
        return {
            "type": "delegation",
            "delegations": event.delegations,
        }
    elif isinstance(event, CollaboratorStartEvent):
        return {
            "type": "collaborator_start",
            "agent_name": event.agent_name,
            "task": event.task,
        }
    elif isinstance(event, CollaboratorCompleteEvent):
        return {
            "type": "collaborator_complete",
            "agent_name": event.agent_name,
            "response": event.response[:500] if event.response else None,
        }
    elif isinstance(event, CompletionEvent):
        return {
            "type": "completion",
            "response": event.response,
        }
    elif isinstance(event, ErrorEvent):
        return {
            "type": "error",
            "error": str(event.error),
        }
    else:
        # Unknown event type
        return None


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8080)
