<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bedsheet Agents - Multi-Agent Patterns Guide</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f6f8fa;
            --bg-tertiary: #eef1f4;
            --text-primary: #1f2328;
            --text-secondary: #57606a;
            --text-muted: #6e7781;
            --accent-blue: #0969da;
            --accent-green: #1a7f37;
            --accent-purple: #8250df;
            --accent-orange: #bf8700;
            --accent-red: #cf222e;
            --border-color: #d0d7de;
            --code-bg: #f6f8fa;
            --sidebar-width: 260px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.7;
            font-size: 16px;
        }

        /* Sidebar Navigation */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: var(--sidebar-width);
            height: 100vh;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 24px 0;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 16px;
        }

        .sidebar-header h1 {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .sidebar-header .subtitle {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .nav-section {
            padding: 8px 20px;
        }

        .nav-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .nav-link {
            display: flex;
            align-items: center;
            padding: 6px 0;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 14px;
            transition: color 0.15s;
        }

        .nav-link:hover {
            color: var(--accent-blue);
        }

        .nav-link .step {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            background: var(--border-color);
            border-radius: 50%;
            font-size: 11px;
            font-weight: 600;
            margin-right: 8px;
            color: var(--text-muted);
        }

        .nav-link:hover .step {
            background: var(--accent-blue);
            color: white;
        }

        /* Main Content */
        .main-content {
            margin-left: var(--sidebar-width);
            max-width: 1000px;
            padding: 48px 64px;
        }

        /* Hero */
        .hero {
            margin-bottom: 48px;
        }

        .hero h1 {
            font-size: 42px;
            font-weight: 700;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .hero .lead {
            font-size: 20px;
            color: var(--text-secondary);
            margin-bottom: 24px;
        }

        .hero .badge-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
        }

        .badge-blue { background: #dbeafe; color: #1e40af; }
        .badge-green { background: #dcfce7; color: #166534; }
        .badge-purple { background: #f3e8ff; color: #6b21a8; }
        .badge-orange { background: #fef3c7; color: #92400e; }

        /* Typography */
        h2 {
            font-size: 28px;
            font-weight: 600;
            margin-top: 64px;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        h2 .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: var(--accent-blue);
            color: white;
            border-radius: 50%;
            font-size: 18px;
        }

        h3 {
            font-size: 20px;
            font-weight: 600;
            margin-top: 40px;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        h4 {
            font-size: 16px;
            font-weight: 600;
            margin-top: 32px;
            margin-bottom: 12px;
            color: var(--text-secondary);
        }

        p {
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        /* Code */
        pre {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 16px 0 24px 0;
            font-size: 14px;
            white-space: pre;
        }

        code {
            font-family: 'JetBrains Mono', monospace;
        }

        p code, li code {
            background: var(--code-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
            color: var(--accent-purple);
        }

        /* Info boxes */
        .info-box {
            border-radius: 8px;
            padding: 16px 20px;
            margin: 20px 0;
            border-left: 4px solid;
        }

        .info-box.tip {
            background: #f0fdf4;
            border-color: var(--accent-green);
        }

        .info-box.note {
            background: #eff6ff;
            border-color: var(--accent-blue);
        }

        .info-box.warning {
            background: #fefce8;
            border-color: var(--accent-orange);
        }

        .info-box.important {
            background: #fef2f2;
            border-color: var(--accent-red);
        }

        .info-box-title {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .tip .info-box-title { color: var(--accent-green); }
        .note .info-box-title { color: var(--accent-blue); }
        .warning .info-box-title { color: var(--accent-orange); }
        .important .info-box-title { color: var(--accent-red); }

        .info-box p:last-child {
            margin-bottom: 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px 16px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Architecture diagram */
        .architecture {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            overflow-x: auto;
            white-space: pre;
        }

        /* Feature grid */
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin: 24px 0;
        }

        .feature-card {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid var(--accent-blue);
        }

        .feature-card h4 {
            margin-top: 0;
            color: var(--accent-blue);
        }

        .feature-card p {
            margin-bottom: 0;
            font-size: 14px;
        }

        /* Pattern cards */
        .pattern-card {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 24px;
            margin: 24px 0;
            border-left: 4px solid var(--accent-purple);
        }

        .pattern-card h3 {
            margin-top: 0;
            color: var(--accent-purple);
        }

        /* Mermaid diagrams */
        .mermaid {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        /* Lists */
        ul, ol {
            margin-left: 24px;
            margin-bottom: 16px;
        }

        li {
            margin-bottom: 8px;
        }

        /* Footer */
        footer {
            margin-top: 64px;
            padding-top: 32px;
            border-top: 1px solid var(--border-color);
            color: var(--text-muted);
            text-align: center;
        }

        footer a {
            color: var(--accent-blue);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .sidebar {
                display: none;
            }
            .main-content {
                margin-left: 0;
                padding: 24px;
            }
            .feature-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <nav class="sidebar">
        <div class="sidebar-header">
            <h1>Bedsheet Agents</h1>
            <div class="subtitle">Multi-Agent Patterns</div>
        </div>

        <div class="nav-section">
            <div class="nav-section-title">Overview</div>
            <a href="#introduction" class="nav-link">Introduction</a>
            <a href="#overview" class="nav-link">Pattern Overview</a>
        </div>

        <div class="nav-section">
            <div class="nav-section-title">Patterns</div>
            <a href="#agents-as-tools" class="nav-link"><span class="step">1</span>Agents-as-Tools</a>
            <a href="#swarms" class="nav-link"><span class="step">2</span>Swarms</a>
            <a href="#agent-graphs" class="nav-link"><span class="step">3</span>Agent Graphs</a>
            <a href="#workflows" class="nav-link"><span class="step">4</span>Workflows</a>
            <a href="#a2a" class="nav-link"><span class="step">5</span>A2A Protocol</a>
        </div>

        <div class="nav-section">
            <div class="nav-section-title">Advanced</div>
            <a href="#combining" class="nav-link">Combining Patterns</a>
            <a href="#best-practices" class="nav-link">Best Practices</a>
        </div>

        <div class="nav-section">
            <div class="nav-section-title">Reference</div>
            <a href="user-guide.html" class="nav-link">User Guide</a>
            <a href="multi-agent-guide.html" class="nav-link">Multi-Agent Guide</a>
            <a href="technical-guide.html" class="nav-link">Technical Guide</a>
        </div>

        <div class="nav-section" style="margin-top: auto; padding-top: 20px; border-top: 1px solid var(--border-color);">
            <div style="font-size: 11px; color: var(--text-muted); line-height: 1.5;">
                <div>&copy; 2025-2026</div>
                <div><strong style="color: var(--text-secondary);">Sivan Grunberg</strong></div>
                <div><a href="https://vitakka.co/" style="color: var(--accent-blue); text-decoration: none;">Vitakka Consulting</a></div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <div class="hero">
            <h1>Multi-Agent Patterns</h1>
            <p class="lead">Implement common multi-agent orchestration patterns using Bedsheet's existing constructs. No additional features required.</p>
            <div class="badge-row">
                <span class="badge badge-blue">Swarms</span>
                <span class="badge badge-green">Agent Graphs</span>
                <span class="badge badge-purple">Workflows</span>
                <span class="badge badge-orange">A2A Protocol</span>
            </div>
        </div>

        <!-- Introduction -->
        <section id="introduction">
            <h2>Introduction</h2>

            <p>This guide shows how to implement common multi-agent orchestration patterns using Bedsheet's existing constructs. The key insight: <strong>these patterns are just different ways of wiring up what Bedsheet already has</strong>.</p>

            <p>You need:</p>
            <ul>
                <li><code>Supervisor</code> for hierarchical coordination</li>
                <li><code>Agent</code> with <code>@action</code> for cross-agent communication</li>
                <li><code>asyncio.gather()</code> for parallel execution</li>
            </ul>

            <div class="info-box tip">
                <div class="info-box-title">No New Features Needed</div>
                <p>Every pattern in this guide can be built today with Bedsheet v0.4+. The patterns are conceptual - the framework already has the primitives.</p>
            </div>
        </section>

        <!-- Pattern Overview -->
        <section id="overview">
            <h2>Pattern Overview</h2>

            <table>
                <thead>
                    <tr>
                        <th>Pattern</th>
                        <th>What It Does</th>
                        <th>Bedsheet Implementation</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Agents-as-Tools</strong></td>
                        <td>Central orchestrator delegates to specialists</td>
                        <td><code>Supervisor</code> with <code>collaborators</code></td>
                    </tr>
                    <tr>
                        <td><strong>Swarms</strong></td>
                        <td>Peer agents hand off to each other</td>
                        <td>Agents with cross-agent <code>@action</code> tools</td>
                    </tr>
                    <tr>
                        <td><strong>Agent Graphs</strong></td>
                        <td>DAG-based pipeline with dependencies</td>
                        <td><code>asyncio.gather()</code> + sequential phases</td>
                    </tr>
                    <tr>
                        <td><strong>Workflows</strong></td>
                        <td>Pre-defined task sequence as single tool</td>
                        <td><code>@action</code> wrapping agent pipeline</td>
                    </tr>
                    <tr>
                        <td><strong>A2A Protocol</strong></td>
                        <td>Dynamic agent discovery and routing</td>
                        <td>Registry + Router <code>Supervisor</code></td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Pattern 1: Agents-as-Tools -->
        <section id="agents-as-tools">
            <h2><span class="step-number">1</span>Agents-as-Tools (Hierarchical Delegation)</h2>

            <p><strong>Use when:</strong> You have a clear orchestrator that decides which specialists to consult.</p>

            <p>This is Bedsheet's native <code>Supervisor</code> pattern:</p>

            <pre><code class="language-python">from bedsheet import Agent, Supervisor, ActionGroup
from bedsheet.llm import AnthropicClient

client = AnthropicClient()

# Create specialist agents
researcher = Agent(
    name="Researcher",
    instruction="Find and summarize information on topics",
    model_client=client,
)

analyst = Agent(
    name="Analyst",
    instruction="Analyze data and provide insights",
    model_client=client,
)

writer = Agent(
    name="Writer",
    instruction="Write clear, engaging content",
    model_client=client,
)

# Create orchestrating supervisor
orchestrator = Supervisor(
    name="ContentTeam",
    instruction="""You coordinate a content team.
    - Use Researcher for gathering information
    - Use Analyst for data interpretation
    - Use Writer for final content creation
    Delegate tasks appropriately and synthesize results.""",
    model_client=client,
    collaborators=[researcher, analyst, writer],
    collaboration="supervisor",  # Parallel delegation
)

# Run
async for event in orchestrator.invoke("session-1", "Write an article about AI trends"):
    print(event)</code></pre>

            <div class="mermaid">
flowchart TB
    User[User Request] --> Orchestrator[ContentTeam<br/>Supervisor]
    Orchestrator --> Researcher[Researcher]
    Orchestrator --> Analyst[Analyst]
    Orchestrator --> Writer[Writer]
    Researcher --> Synthesis[Synthesize]
    Analyst --> Synthesis
    Writer --> Synthesis
    Synthesis --> Response[Final Response]

    style Orchestrator fill:#dbeafe,stroke:#0969da,color:#1f2328
    style Researcher fill:#dcfce7,stroke:#1a7f37,color:#1f2328
    style Analyst fill:#dcfce7,stroke:#1a7f37,color:#1f2328
    style Writer fill:#dcfce7,stroke:#1a7f37,color:#1f2328
            </div>
        </section>

        <!-- Pattern 2: Swarms -->
        <section id="swarms">
            <h2><span class="step-number">2</span>Swarms (Peer-to-Peer Collaboration)</h2>

            <p><strong>Use when:</strong> Agents should autonomously decide when to hand off to peers, with no central controller.</p>

            <pre><code class="language-python">from bedsheet import Agent, ActionGroup
from bedsheet.events import CompletionEvent

client = AnthropicClient()

# Create agents that will form a swarm
researcher = Agent(
    name="Researcher",
    instruction="Research topics. Hand off to Analyst when you have data.",
    model_client=client,
)

analyst = Agent(
    name="Analyst",
    instruction="Analyze data. Hand off to Writer when insights are ready.",
    model_client=client,
)

writer = Agent(
    name="Writer",
    instruction="Write final content based on analysis.",
    model_client=client,
)

# Give each agent the ability to hand off to others
async def create_handoff_action(from_agent: Agent, to_agent: Agent):
    """Create a handoff tool from one agent to another."""

    @from_agent.default_action_group.action(
        name=f"handoff_to_{to_agent.name.lower()}",
        description=f"Hand off work to {to_agent.name} with context"
    )
    async def handoff(context: str, task: str) -> str:
        """Hand off to the next agent with context."""
        message = f"Context from {from_agent.name}:\n{context}\n\nTask: {task}"
        result = ""
        async for event in to_agent.invoke(f"swarm-session", message):
            if isinstance(event, CompletionEvent):
                result = event.text
        return result

# Wire up the swarm connections
await create_handoff_action(researcher, analyst)
await create_handoff_action(analyst, writer)
await create_handoff_action(writer, researcher)  # Can loop back if needed

# Start the swarm with the researcher
async for event in researcher.invoke(
    "swarm-session",
    "Research AI trends, analyze the findings, and write a summary"
):
    print(event)</code></pre>

            <div class="info-box note">
                <div class="info-box-title">Key Insight</div>
                <p>Each agent has <code>@action</code> tools to invoke other agents. The LLM decides when to hand off based on its instruction. No central coordinator needed.</p>
            </div>

            <div class="mermaid">
flowchart LR
    R[Researcher] -->|handoff_to_analyst| A[Analyst]
    A -->|handoff_to_writer| W[Writer]
    W -->|handoff_to_researcher| R

    style R fill:#dbeafe,stroke:#0969da,color:#1f2328
    style A fill:#dcfce7,stroke:#1a7f37,color:#1f2328
    style W fill:#f3e8ff,stroke:#8250df,color:#1f2328
            </div>
        </section>

        <!-- Pattern 3: Agent Graphs -->
        <section id="agent-graphs">
            <h2><span class="step-number">3</span>Agent Graphs (DAG-Based Pipelines)</h2>

            <p><strong>Use when:</strong> You have explicit dependencies between processing stages.</p>

            <pre><code class="language-python">import asyncio
from bedsheet import Agent
from bedsheet.events import CompletionEvent

client = AnthropicClient()

# Define pipeline stages as agents
fetcher_a = Agent(name="FetcherA", instruction="Fetch data from source A", model_client=client)
fetcher_b = Agent(name="FetcherB", instruction="Fetch data from source B", model_client=client)
fetcher_c = Agent(name="FetcherC", instruction="Fetch data from source C", model_client=client)
merger = Agent(name="Merger", instruction="Merge multiple data sources", model_client=client)
analyzer = Agent(name="Analyzer", instruction="Analyze merged data", model_client=client)
formatter = Agent(name="Formatter", instruction="Format results for output", model_client=client)

async def get_result(agent: Agent, session_id: str, message: str) -> str:
    """Helper to get final text from an agent."""
    async for event in agent.invoke(session_id, message):
        if isinstance(event, CompletionEvent):
            return event.text
    return ""

async def run_pipeline(query: str) -> str:
    """
    Pipeline graph:

        FetcherA ─┐
        FetcherB ─┼─► Merger ─┬─► Analyzer ─► (output)
        FetcherC ─┘           │
                              └─► Formatter ─► (output)
    """
    session = "pipeline-session"

    # Phase 1: Parallel fetching (no dependencies)
    fetch_results = await asyncio.gather(
        get_result(fetcher_a, session, f"Fetch source A data for: {query}"),
        get_result(fetcher_b, session, f"Fetch source B data for: {query}"),
        get_result(fetcher_c, session, f"Fetch source C data for: {query}"),
    )

    # Phase 2: Merge (depends on all fetchers)
    merged = await get_result(
        merger, session,
        f"Merge these data sources:\n" + "\n---\n".join(fetch_results)
    )

    # Phase 3: Parallel processing (both depend on merger)
    analysis, formatted = await asyncio.gather(
        get_result(analyzer, session, f"Analyze: {merged}"),
        get_result(formatter, session, f"Format for display: {merged}"),
    )

    return f"Analysis:\n{analysis}\n\nFormatted:\n{formatted}"

# Run the pipeline
result = await run_pipeline("quarterly sales data")
print(result)</code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Key Insight</div>
                <p>Use <code>asyncio.gather()</code> for parallel stages, sequential <code>await</code> for dependencies. The graph structure is in your code, not configuration.</p>
            </div>

            <div class="architecture">
    Pipeline Graph:

        FetcherA ─┐
        FetcherB ─┼─► Merger ─┬─► Analyzer ─► (output)
        FetcherC ─┘           │
                              └─► Formatter ─► (output)

    Phase 1: asyncio.gather(A, B, C)  ← Parallel
    Phase 2: await merger(...)         ← Sequential
    Phase 3: asyncio.gather(analyzer, formatter)  ← Parallel</div>
        </section>

        <!-- Pattern 4: Workflows -->
        <section id="workflows">
            <h2><span class="step-number">4</span>Workflows (Task DAGs as Tools)</h2>

            <p><strong>Use when:</strong> You have repeatable multi-step processes that should be exposed as a single operation.</p>

            <pre><code class="language-python">from bedsheet import Agent, ActionGroup
from bedsheet.events import CompletionEvent

client = AnthropicClient()

# Create workflow step agents
validator = Agent(name="Validator", instruction="Validate order data", model_client=client)
inventory_checker = Agent(name="InventoryChecker", instruction="Check stock levels", model_client=client)
payment_processor = Agent(name="PaymentProcessor", instruction="Process payments", model_client=client)
shipper = Agent(name="Shipper", instruction="Arrange shipping", model_client=client)
notifier = Agent(name="Notifier", instruction="Send customer notifications", model_client=client)

# Main agent that uses the workflow
order_agent = Agent(
    name="OrderManager",
    instruction="Process customer orders using the process_order workflow",
    model_client=client,
)

order_group = ActionGroup(name="Orders", description="Order processing tools")

@order_group.action(
    name="process_order",
    description="Complete order processing workflow: validate → check inventory → process payment → ship → notify"
)
async def process_order(order_id: str, customer_email: str, items: str) -> dict:
    """Execute the full order processing workflow."""
    session = f"order-{order_id}"

    async def run_step(agent: Agent, message: str) -> str:
        async for event in agent.invoke(session, message):
            if isinstance(event, CompletionEvent):
                return event.text
        return ""

    # Step 1: Validate
    validation = await run_step(
        validator,
        f"Validate order {order_id}: items={items}, email={customer_email}"
    )
    if "invalid" in validation.lower():
        return {"status": "failed", "step": "validation", "message": validation}

    # Step 2: Check inventory
    inventory = await run_step(
        inventory_checker,
        f"Check stock for order {order_id}: {items}"
    )
    if "out of stock" in inventory.lower():
        return {"status": "failed", "step": "inventory", "message": inventory}

    # Step 3: Process payment
    payment = await run_step(
        payment_processor,
        f"Process payment for order {order_id}"
    )

    # Step 4: Arrange shipping
    shipping = await run_step(
        shipper,
        f"Ship order {order_id} to customer"
    )

    # Step 5: Notify customer
    notification = await run_step(
        notifier,
        f"Send confirmation to {customer_email} for order {order_id}"
    )

    return {
        "status": "completed",
        "order_id": order_id,
        "steps": {
            "validation": validation,
            "inventory": inventory,
            "payment": payment,
            "shipping": shipping,
            "notification": notification,
        }
    }

order_agent.add_action_group(order_group)

# Now the agent can use the workflow as a single tool
async for event in order_agent.invoke(
    "session-1",
    "Process order #12345 for customer@example.com with items: Widget x2, Gadget x1"
):
    print(event)</code></pre>

            <div class="info-box note">
                <div class="info-box-title">Key Insight</div>
                <p>Wrap the entire multi-agent pipeline in a single <code>@action</code>, exposing it as one tool to the outer agent. The workflow becomes a black box.</p>
            </div>
        </section>

        <!-- Pattern 5: A2A Protocol -->
        <section id="a2a">
            <h2><span class="step-number">5</span>A2A Protocol (Dynamic Agent Discovery)</h2>

            <p><strong>Use when:</strong> Agents need to discover and route to other agents based on capabilities at runtime.</p>

            <pre><code class="language-python">from bedsheet import Agent, Supervisor, ActionGroup
from bedsheet.events import CompletionEvent
from dataclasses import dataclass

client = AnthropicClient()

@dataclass
class AgentCapability:
    agent: Agent
    capabilities: list[str]
    description: str

class AgentRegistry:
    """Registry for agent discovery."""

    def __init__(self):
        self.agents: dict[str, AgentCapability] = {}

    def register(self, agent: Agent, capabilities: list[str], description: str):
        self.agents[agent.name] = AgentCapability(agent, capabilities, description)

    def find_by_capability(self, capability: str) -> Agent | None:
        for entry in self.agents.values():
            if capability in entry.capabilities:
                return entry.agent
        return None

    def list_capabilities(self) -> str:
        lines = []
        for name, entry in self.agents.items():
            lines.append(f"- {name}: {', '.join(entry.capabilities)} - {entry.description}")
        return "\n".join(lines)

# Create the registry
registry = AgentRegistry()

# Register agents with capabilities
math_agent = Agent(name="MathExpert", instruction="Solve math problems", model_client=client)
registry.register(math_agent, ["math", "calculation", "statistics"], "Mathematical computations")

code_agent = Agent(name="CodeExpert", instruction="Write and debug code", model_client=client)
registry.register(code_agent, ["coding", "debugging", "python", "javascript"], "Software development")

data_agent = Agent(name="DataExpert", instruction="Analyze and visualize data", model_client=client)
registry.register(data_agent, ["data-analysis", "visualization", "sql"], "Data science")

# Create a router that uses the registry
router = Agent(
    name="Router",
    instruction=f"""You are a task router. Route requests to the appropriate expert.

Available experts:
{registry.list_capabilities()}

Use the route_to_expert tool to delegate tasks.""",
    model_client=client,
)

router_group = ActionGroup(name="Routing", description="Route to experts")

@router_group.action(
    name="route_to_expert",
    description="Route a task to an expert based on required capability"
)
async def route_to_expert(capability: str, task: str) -> str:
    """Find an agent with the capability and delegate the task."""
    agent = registry.find_by_capability(capability)
    if not agent:
        return f"No agent found with capability: {capability}"

    result = ""
    async for event in agent.invoke(f"routed-{capability}", task):
        if isinstance(event, CompletionEvent):
            result = event.text
    return f"[{agent.name}]: {result}"

@router_group.action(
    name="list_available_experts",
    description="List all available experts and their capabilities"
)
async def list_available_experts() -> str:
    return registry.list_capabilities()

router.add_action_group(router_group)

# The router dynamically discovers and delegates
async for event in router.invoke(
    "session-1",
    "Calculate the standard deviation of [1,2,3,4,5] and then write Python code to verify it"
):
    print(event)</code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Key Insight</div>
                <p>Use a registry pattern with capability tags. The router agent discovers agents at runtime based on what's registered, not hardcoded.</p>
            </div>
        </section>

        <!-- Combining Patterns -->
        <section id="combining">
            <h2>Combining Patterns</h2>

            <p>These patterns can be combined. For example:</p>

            <ul>
                <li><strong>Supervisor + Workflows:</strong> A supervisor delegates to agents, some of which execute internal workflows</li>
                <li><strong>Swarm + A2A:</strong> Swarm agents use a registry to discover peers dynamically</li>
                <li><strong>Graph + Workflows:</strong> A pipeline where some nodes are entire workflows</li>
            </ul>

            <pre><code class="language-python"># Example: Supervisor with workflow-wrapped specialists
supervisor = Supervisor(
    name="TeamLead",
    instruction="Coordinate the team",
    model_client=client,
    collaborators=[
        order_agent,      # Has process_order workflow tool
        data_agent,       # Has analyze_data workflow tool
        report_agent,     # Has generate_report workflow tool
    ],
)</code></pre>
        </section>

        <!-- Best Practices -->
        <section id="best-practices">
            <h2>Best Practices</h2>

            <ol>
                <li><strong>Start simple:</strong> Use <code>Supervisor</code> first. Add complexity only when needed.</li>
                <li><strong>Clear handoff context:</strong> When agents hand off, include full context so the next agent doesn't need to ask questions.</li>
                <li><strong>Session management:</strong> Use consistent <code>session_id</code> patterns:
                    <ul>
                        <li><code>f"{workflow}-{step}"</code> for pipelines</li>
                        <li><code>f"{parent}-{child}"</code> for hierarchies</li>
                        <li>Unique IDs for independent work</li>
                    </ul>
                </li>
                <li><strong>Error handling:</strong> Wrap agent invocations in try/except and return meaningful error messages.</li>
                <li><strong>Logging:</strong> Emit custom events or use print statements to trace multi-agent flows during development.</li>
            </ol>

            <div class="info-box warning">
                <div class="info-box-title">When to Use Which Pattern</div>
                <p>
                    <strong>Supervisor</strong> - Clear hierarchy, central coordination<br>
                    <strong>Swarms</strong> - Creative collaboration, emergent behavior<br>
                    <strong>Graphs</strong> - ETL pipelines, multi-stage processing<br>
                    <strong>Workflows</strong> - Repeatable business processes<br>
                    <strong>A2A</strong> - Dynamic, capability-based routing
                </p>
            </div>

            <h3>See Also</h3>

            <ul>
                <li><a href="multi-agent-guide.html">Multi-Agent Guide</a> - Supervisor and Router patterns in depth</li>
                <li><a href="technical-guide.html">Technical Guide</a> - Core Bedsheet patterns</li>
                <li><a href="user-guide.html">User Guide</a> - Getting started with agents</li>
            </ul>
        </section>

        <footer>
            <p><strong>Copyright &copy; 2025-2026 Sivan Grunberg, <a href="https://vitakka.co/">Vitakka Consulting</a></strong></p>
            <p style="margin-top: 8px;">Licensed under the Elastic License 2.0</p>
            <p style="margin-top: 8px;">
                <a href="user-guide.html">User Guide</a> &middot;
                <a href="multi-agent-guide.html">Multi-Agent Guide</a> &middot;
                <a href="technical-guide.html">Technical Guide</a> &middot;
                <a href="https://github.com/sivang/bedsheet">GitHub</a>
            </p>
        </footer>
    </main>

    <script>
        // Initialize Mermaid with light theme
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#e3f2fd',
                primaryTextColor: '#1f2328',
                primaryBorderColor: '#0969da',
                lineColor: '#57606a',
                secondaryColor: '#f0fdf4',
                tertiaryColor: '#fef3c7'
            }
        });

        // Initialize syntax highlighting
        hljs.highlightAll();
    </script>
</body>
</html>
